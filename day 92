class Node:
    def __init__(self, x):
        self.data = x
        self.left = None
        self.right = None

# Get inorder traversal
def inorder(root, arr):
    if root:
        inorder(root.left, arr)
        arr.append(root.data)
        inorder(root.right, arr)

# Fix BST by sorting inorder and writing back
def correctBST(root):
    arr = []
    inorder(root, arr)
    arr.sort()

    # Write back sorted values
    def fill(root):
        if root:
            fill(root.left)
            root.data = arr.pop(0)
            fill(root.right)
    fill(root)

# Level order print (compact)
def levelOrder(root):
    from collections import deque
    q = deque([root])
    while q:
        node = q.popleft()
        print(node.data if node else "N", end=" ")
        if node:
            q.append(node.left)
            q.append(node.right)

# -------------------------
# Example Usage
# -------------------------
root = Node(6)
root.left = Node(10)
root.right = Node(2)
root.left.left = Node(1)
root.left.right = Node(3)
root.right.left = Node(7)
root.right.right = Node(12)

correctBST(root)
levelOrder(root)

